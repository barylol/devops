## Linux middle

1. Что такое системный вызов, какие они бывают?

    <details>
      <summary>Ответ</summary>

    Системный вызов - обращение программы к ядру операционной системы для выполнения какой-либо операции.

    В Unix, Unix-like и других POSIX-совместимых операционных системах популярными системными вызовами являются:

    * open
    * read
    * write
    * close
    * wait
    * exec 
    * fork
    * exit
    * kill

    </details>

---

2. Что такое процесс? Что такое поток? В чём отличие между процессом и потоком?

    <details>
      <summary>Ответ</summary>

    Процесс — экземпляр программы во время выполнения, независимый объект, которому выделены системные ресурсы (например, процессорное время и память). Каждый процесс выполняется в отдельном адресном пространстве: один процесс не может получить доступ к переменным и структурам данных другого. Поток (thread) - сущность операционной системы, процесс выполнения на процессоре программного кода. Общее назначение потоков — параллельное выполнение на процессоре двух или более различных задач. Каждый процесс имеет как минимум один поток.

    </details>

---

3. Что такое сигналы в Unix? Зачем они нужны?

    <details>
      <summary>Ответ</summary>

    Сигнал в Unix-подобных операционных системах - асинхронное (происходящее в случайное время) уведомление процесса о каком-либо событии, один из основных способов взаимодействия между процессами. Когда сигнал послан процессу, операционная система прерывает выполнение процесса, при этом, если процесс установил собственный обработчик сигнала, операционная система запускает этот обработчик, передав ему информацию о сигнале, если процесс не установил обработчика, то выполняется обработчик по умолчанию.

    Отправка сигналов от одного процесса к другому обычно осуществляется при помощи системного вызова *kill*. Его первый параметр – PID процесса, которому отправляется сигнал, второй параметр – номер сигнала.

    ```bash
    kill(1111, SIGTERM);
    ```

    При вызове из командной строки можно пользоваться форматом ```kill -signalNumber PID```. Например, для отправки сигнала безусловного завершения процессу с PID 12345 нужно выполнить команду

    ```bash
    kill -9 12345
    ```

    Стандарт POSIX определяет 28 сигналов, жирным выделены сигналы, с которыми пользователь сталкивается чаще всего:

    | Название | Номер | Действие по умолчанию | Описание | Тип |
    |-|-|-|-|-|
    | **SIGHUP** | **1** | **Завершение** | **Закрытие терминала** | **Уведомление** |
    | **SIGINT** | **2** | **Завершение** | **Сигнал прерывания выполнения (Ctrl + C) с терминала** | **Управление** |
    | SIGQUIT | 3 | Завершение с дампом памяти | Сигнал "Quit" (Ctrl + \\) с терминала | Управление |
    | SIGILL | 4 | Завершение с дампом памяти | Недопустимая инструкция процессора | Исключение |
    | SIGTRAP | 5 | Завершение с дампом памяти |  Ловушка трассировки или брейкпоинт | Отладка |
    | SIGABRT | 6 | Завершение с дампом памяти | Сигнал, посылаемый функцией abort() | Управление |
    | SIGFPE | 8 | Завершение с дампом памяти | Ошибочная арифметическая операция | Исключение |
    | **SIGKILL** | **9** | **Завершение** | **Безусловное завершение** | **Управление** |
    | SIGBUS | 10 | Завершение с дампом памяти | Неправильное обращение в физическую память | Исключение |
    | SIGSEGV | 11 | Завершение с дампом памяти | Нарушение при обращении в память | Исключение |
    | SIGSYS | 12 | Завершение с дампом памяти | Неправильный системный вызов | Исключение |
    | SIGPIPE | 13 | Завершение | Запись в разорванное соединение (пайп, сокет) | Уведомление |
    | SIGALRM | 14 | Завершение | Сигнал истечения времени, заданного alarm() | Уведомление |
    | **SIGTERM** | **15** | **Завершение** | **Сигнал завершения (сигнал по умолчанию для утилиты kill)** | **Управление** |
    | SIGUSR1 | 16 | Завершение | Пользовательский сигнал №1 | Пользовательский |
    | SIGUSR2 | 17 | Завершение | Пользовательский сигнал №2 | Пользовательский |
    | SIGCHLD | 18 | Игнорируется | Дочерний процесс завершен или остановлен | Уведомление |
    | **SIGTSTP** | **20** | **Остановка процесса** | **Сигнал остановки (Ctrl + Z) с терминала** | **Управление** |
    | SIGURG | 21 | Игнорируется | На сокете получены срочные данные | Уведомление |
    | SIGPOLL | 22 | Завершение | Событие, отслеживаемое poll() | Уведомление |
    | **SIGSTOP** | **23** | **Остановка процесса** | **Остановка выполнения процесса** | **Управление** |
    | **SIGCONT** | **25** | **Продолжить выполнение** | **Продолжить выполнение ранее остановленного процесса** | **Управление** |
    | SIGTTIN | 26 | Остановка процесса | Попытка чтения с терминала фоновым процессом | Управление |
    | SIGTTOU | 27 | Остановка процесса | Попытка записи на терминал фоновым процессом | Управление |
    | SIGVTALRM | 28 | Завершение | Истечение «виртуального таймера» | Уведомление |
    | SIGPROF | 29 | Завершение | Истечение таймера профилирования | Отладка |
    | SIGXCPU | 30 | Завершение с дампом памяти | Процесс превысил лимит процессорного времени | Исключение |
    | SIGXCPU | 31 | Завершение с дампом памяти | Процесс превысил допустимый размер файла | Исключение |

    </details>

---

4. В чём отличие между сигналами 9, 15 и 23?

    <details>
      <summary>Ответ</summary>

    Сигнал 9 это немедленное и безусловное завершение процесса. Сигнал 15 это штатная остановка процесса, подразумевающая плановое завершение всех операций, связанных с этим процессом. Сигнал 23 это постановка выполнения процесса на паузу. Возобновить работу процесса, поставленного на паузу, можно при помощи сигнала 25.

    </details>

---

5. Что такое Exit-code или код завершения?

    <details>
      <summary>Ответ</summary>

    Exit-code или код завершения это целое число в диапазоне от 0 до 255, которое возвращает программа или скрипт после выполнения. Этот число обозначает результат выполнения. Также exit-код является аргументом bash-команды exit, например ```exit 130```. Посмотреть значение кода завершения последней исполненной команды в bash можно при помощи ```echo $?```. При помощи кодов завершения можно добавлять логику выполнения команд в bash-скрипты, например обработку кодов, свитетельствующих об ошибках. В bash существуют зарезервированные коды завершения:

    | Код | Описание |
    | - | - |
    | 0 | Успешное выполнение команды |
    | 1 | Ошибка выполнения команды |
    | 2 | Пропущен аргумент или ключевое слово команды |
    | 126 | Вызванная команда не может быть исполнена |
    | 127 | Указанная команда не найдена |
    | 128 | Неверный аргумент команды exit, например ```exit 3.14159``` |
    | 128 + n | Фатальная ошибка с сигналом n. Например, команда kill -9 PID вернёт код возврата 137 |
    | 130 | Завершение команды по Ctrl + C, то есть по сигналу 2 (130 = 128 + 2) |
    | 255 | Аргумент команды exit вне диапазона от 0 до 255, например ```exit -1``` |

    Более подробный список кодов завершения можно увидеть тут:

    <https://www.cyberciti.biz/faq/linux-bash-exit-status-set-exit-statusin-bash/>

    </details>

---

6. Что такое Inode? Какая информация там хранится?

    <details>
      <summary>Ответ</summary>

      Inode (индексный дескриптор) - структура данных, в которой хранятся метаданные файла и перечислены блоки с данными файла. Хранит всю информацию, кроме имени файла и данных. Каждый файл в данном каталоге является записью с именем файла и номером индекса. Вся остальная информация о файле извлекается из таблицы индексов путем ссылки на номер индекса. Номера Inode уникальны на уровне раздела. Каждый раздел представляет собой собственную таблицу индексов. Если в разделе диска закончились Inode, то создание новых файлов становится невозможным, даже если в разделе есть свободное место.

      Метаданные, которые хранятся в Inode:
      * Размер
      * Разрешение
      * Владелец/группа
      * Расположение жесткого диска
      * Дата/время
      * Любая другая необходимая информация

    </details>

---

8. Какие состояния процессов существуют? Что значит состояние процесса D?

    <details>
      <summary>Ответ</summary>

    |                   **Статус**                   |               **Описание**              |
    |:----------------------------------------------:|:---------------------------------------:|
    | R (Running or runnable)                        | Процесс выполняется в данный момент     |
    | S (Interruptible sleep)                        | Неактивен (спит менее 20 сек)           |
    | D (Uninterruptible sleep)                      | Ожидает записи на диск                  |
    | T (stopped by job control signal)              | Остановлен или трассируется отладчиком  |
    | Z (zombie)                                     | Процесс-зомби                           |
    | W (paging (not valid since the 2.6.xx kernel)) | Процесс выгружен на своп-раздел диска   |
    | <                                              | Процесс имеет повышенный приоритет nice |
    | N                                              | Процесс имеет пониженный приоритет nice |
    | L (locked)                                     | Некоторые страницы блокированы в памяти |
    | s                                              | Процесс является лидером сеанса         |

    </details>

---

9. Что такое процесс-зомби и процесс-сирота?

    <details>
      <summary>Ответ</summary>

      *Процесс-зомби* - дочерний процесс в Unix-системе, который завершил своё выполнение, но код завершения которого ещё не был считан родительским процессом. Процессы-зомби присутствуют в списке процессов операционной системы и обозначаются буквой Z. Удаление процесса-зомби возлагается на родительский процесс или на системный вызов `wait()`. Если родительский процесс не удалит своих потомков, то они останутся в состоянии зомби. Процессы-зомби не потребляют ресурсы, однако занимают записи в таблице процессов, что при наличии большого количества процссов-зомби может привести к невозможности создания новых процессов. Завершить процесс-зомби напрямую невозможно. Чтобы убить процесс-зомби, нужно найти родительский процесс и завершить его. Найти процессы-зомби и их родителей можно следующей командой:
      
      ```bash
      ps ajx | grep -w Z
      ```
      
      PID'ы процессов родителей в 3 колонке. Убить процесс можно следующей командой:
      
      ```bash
      kill -9 <PID процесса родителя>
      ```

      *Процесс-сирота* - вспомогательный процесс в Unix-системе, чей процесс-родитель был завершен нештатно, то есть не подав сигнал на завершение работы. Отличие между процессом-зомби и процессом-сиротой в том, что процесс-сирота является активным, то есть выполняется, а процесс-зомби завершил своё выполнение. После нештатного прерывания родительского процесса, процесс-сирота переходит под управление init, процесса инициализации с PID 1. Процесс-сирота может быть создан пользователем при отсоединении выполняемого процесса от терминала. В отличие от процессов-зомби, процессы-сироты могут быть найдены и остановлены по отдельности. Делается это следующим образом:

      Вывести список процессов в виде дерева:

      ```bash
      ps afux
      ```

      Найти в списке процессы-сироты с родительским процессом init и завершить их при помощи команды ```kill -9 <PID процесса-сироты>```

    </details>

---

10. Что такое файловый дескриптор? Какая информация там хранится?

    <details>
      <summary>Ответ</summary>

    *Файловый дескриптор* - неотрицательное целое число, которое используется в интерфейсе между пространством пользователя и пространством ядра (Kernel) для идентификации ресурсов файла/сокета. Когда создаётся новый поток ввода-вывода, ядро возвращает процессу, создавшему поток ввода-вывода, его файловый дескриптор.
    
    </details>

---

11. Что такое buffer/cache память? Для чего нужна?

    <details>
      <summary>Ответ</summary>

    buff/cache память - рассчитанная память, которая зарезервирована, но может быть освобождена при необходимости и используется для быстрого доступа программами к данным, которые находятся в оперативной памяти (быстрой памяти).

    buffers — буферы в памяти — страницы памяти, зарезервированные системой для выделения их процессам, когда они затребуют этого, так же известна как heap-memory;
    cached — файлы, которые недавно были использованы системой/процессами и хранящиеся в памяти на случай если вскоре они снова потребуются.

    </details>

---

12. Как настроить master-slave репликацию в mysql (кратко)?

    <details>
      <summary>Ответ</summary>

    Необходимы 2 сервера: master и slave.

    1. На обеих сервера устанавливаем сервер MySQL одинаковой версии.
    2. Включаем сервер базы данных на обеих серверах.
    3. Настраиваем master - в `/etc/my.cnf` устанавливаем слеюущие значения:
    ```
    # выбираем ID сервера, произвольное число, лучше начинать с 1
    server-id = 1
    # путь к бинарному логу
    log_bin = /var/log/mysql/mysql-bin.log
    # название Вашей базы данных, которая будет реплицироваться
    binlog_do_db = newdatabase
    ```
    Перезапускаем сервер базы данных.
    4. Подключаемся к master серверу, создаем пользователя и назначаем ему права для выполнения репликации.
    ```
    mysql -u root -p <пароль root сервера БД>
    GRANT REPLICATION SLAVE ON *.* TO 'slave_user'@'%' IDENTIFIED BY 'password';
    FLUSH PRIVILEGES;
    ```
    5. На master сервере делаем дамп базы данных c блокировкой таблиц.
    ```
    mysqldump -u root -p --lock-all-tables newdatabase > newdatabase.sql
    ```
    6. Переносим дамп базы на slave сервер, создаем базу данных с таким же именем и импортируем базу.
    ```
    CREATE DATABASE newdatabase;
    mysql -u root -p newdatabase < newdatabase.sql
    ```
    7. Настраиваем slave в `/etc/my.cnf`:
    ```
    # ID Слейва, удобно выбирать следующим числом после Мастера
    server-id = 2
    # Путь к relay логу
    relay-log = /var/log/mysql/mysql-relay-bin.log
    # Путь к bin логу на Мастере
    log_bin = /var/log/mysql/mysql-bin.log
    # База данных для репликации
    binlog_do_db = newdatabase
    ```
    Перезапускаем сервер базы данных.
    8. Запускаем репликацию на slave сервере.
    ```
    CHANGE MASTER TO MASTER_HOST='10.10.0.1', MASTER_USER='slave_user', MASTER_PASSWORD='password',
    MASTER_LOG_FILE = 'mysql-bin.000001', MASTER_LOG_POS = 107;
    ##Указанные значения мы берем из настроек Мастера
    После этого запускаем репликацию на Слейве:
    START SLAVE;
    ```
    9. Проверяем статус репликации:
    ```
    SHOW SLAVE STATUSG
    ```

    </details>

---

13. Представлен вывод команды `free`.

    ```bash
    $ free -m
                  total        used        free      shared  buff/cache   available
    Mem:           6930        3598         843         183        2489        2919
    Swap:         15999           4       15995
    ```

    Почему доступной (available) памяти сейчас 2919, если свободной (free) памяти 843?

    <details>
      <summary>Ответ</summary>

    - Total. Эта цифра представляет всю существующую память.
    - Used вычисление общего значения оперативной памяти системы за вычетом выделенной свободной, разделяемой, буферной и кэш-памяти.

    ```bash
    used = total - free - buff/cache
    ```
    - Free – свободная память в системе.
    - Shared – память, используемая (преимущественно) в tmpfs
    - Buffer, и Cache идентифицируют память, используемую для нужд ядра / операционной системы. Буфер и кеш складываются вместе, а сумма указывается в разделе «buff/cache».
    - Available – примерное количество оперативной памяти, доступное для запуска новых приложений без использования ими раздела подкачки. В отличие от поля free, это поле принимает в расчёт страницу cache и также то, что не вся рекуперируемая (пригодная для повторного использования) память будет возвращена для рекуперации из-за того, что элементы используются в данный момент.

    </details>

---

14. Как исправить ошибку No Space Left on Device, когда свободное место на самом деле есть?

    <details>
      <summary>Ответ</summary>

    Последовательность действий:

    1. Убедиться, что на диске действительно есть свободное место. Это можно сделать, сравнив вывод команд du и df. Для начала нужно выполнить du для всех разделов, куда смонтированы диски. По умолчанию, таким разделом является рут:

    ```bash
    sudo du -sh /
    ```

    После этого, нужно выполнить команду ```df -h```, которая отобразит свободное место на всех дисках. Если значения, полученные после выполнения du и df отличаются, это означает что действительно есть проблема.

    2. Проверить, есть ли удалённые файлы, которые используются процессами? Делается это при помощи команд

    ```bash
    sudo lsof / | grep deleted
    ```

    или

    ```bash
    sudo lsof / | grep -i del
    ```

    В выводе данных команд должен присутствовать процесс. Если его перезапустить, то он перестанет использовать удалённые файлы. Делается это при помощи команды

    ```bash
    sudo systemctl restart PROCESS_NAME
    ```

    3. Проверить, есть ли свободные Inode на дисках. Inode могут закончиться, если было создано много маленьких файлов. Для проверки нужно выполнить ```df -ih``` для всех разделов, куда смонтированы диски. По умолчанию, таким разделом является рут:

    ```bash
    sudo df -ih /
    ```

    Если Inode действительно закончились, нужно найти папку, которая использует наибольшее количество Inode. Например, команда для поиска количества используемых Inode в папках, находящихся в корне:

    ```bash
    for i in /*; do echo $i; find $i | wc -l; done
    ```
    
    После того, как удалось найти корневую папку с наибольшим количеством используемых Inode, нужно повторить эту команду уже для этой корневой папки. Например, для папки /var она будет выглядеть так:

    ```bash
    for i in /var/*; do echo $i; find $i | wc -l; done
    ```

    Обычно, чаще всего много временных файлов создаётся в /var/log или /var/cache, однако они могут присутствовать и в других папках. После удаления множества маленьких файлов, использующих Inode, проблема с созданием новых файлов должна исчезнуть.

    4. Если шаги 1-3 не помогли, можно проверить жёсткие диски в системе на наличие битых блоков. Это можно сделать при помощи утилиты fsck, предварительно или размонтировав проверяемый раздел, или перезагрузившись в безопасном режиме, или загрузившись с LiveCD. Например, для раздела /dev/sda1 команда будет выглядеть так:

    ```bash
    sudo fsck -y /dev/sda1
    ``` 

    </details>

---

15. Как восстановить удалённые файлы?

    <details>
      <summary>Ответ</summary>

    При помощи утилит testdisk или foremost.

    </details>

---

16. Как можно отладить код в Linux?

    <details>
      <summary>Ответ</summary>

    При помощи GDB (GNU Debugger)

    </details>

---

17. Как ограничить использование ресурсов процессом?

    <details>
      <summary>Ответ</summary>

    Использование процессора можно ограничить при помощи cpulimit. Например, ограничить использование процессора до 10% для процесса с PID 1148803:

    ```bash 
    cpulimit -p 1148803 -l 10
    ```

    Ограничить mysql использование процессора до 20%:

    ```bash
    cpulimit -e /usr/bin/mysql -l 20
    ```

    Использование памяти можно ограничить при помощи ulimit. Так как все процессы в системе запускаются от какого-то пользователя, ulimit ограничивает ресурсы, доступные для конкретных пользователей. Файл конфигурации ulimit находится по пути /etc/security/limits.conf. Лимиты бывают двух типов, мягкие и жёсткие.

    * Мягкий лимит (Soft limit) - лимит, установленный пользователем. Его можно как увеличить, так и уменьшить.
    * Жёсткий лимит (Hard limit) - лимит, установленный администратором системы. Пользователь не может задать мягкий лимит выше значения жёсткого лимита.

    Подробное описание команды ulimit:

    <https://russianblogs.com/article/4143387117/>

    <https://andreyex.ru/linux/kak-ustanovit-znachenie-ulimit-v-linux-navsegda/>

    </details>

---

18. Что такое SWAP в Linux?

    <details>
      <summary>Ответ</summary>

    swap — это специальная системная область, предварительно выделенная на накопителе (жёстком диске) и используемая операционной системой с целью резервирования свободного пространства, которое может быть задействовано при нехватке ОЗУ.

    В Linux используется два варианта области подкачки:

      В виде раздела на накопителе.
      В виде файла.
    В современных условиях предпочтительнее использовать swap в виде файла.

    Особенности swap-файла:

    Можно легко изменять размер или полностью удалить, что затруднительно для варианта в виде раздела.
    В сравнении со swap-разделом есть незначительное снижение производительности.
    Для использования гибернации требуется дополнительная подготовка (получение UUID и смещения заголовка) и пересоздание загрузочного образа initrd.

    </details>

